Explications ligne-par-ligne et par bloc pour le dossier APPLICATION

BUT : Aider l'apprenant à comprendre chaque fichier du dossier `APPLICATION` afin qu'il puisse coder seul par la suite.

=== FICHIERS PYTHON PRINCIPAUX ===

--- ajouter_livres.py ---
1  #!/usr/bin/env python
   -> Indique l'interpréteur (shebang). Utile sous UNIX pour exécuter le script directement.
2  # -*- coding: utf-8 -*-
   -> Déclare l'encodage du fichier en UTF-8 (assure la gestion des caractères accentués).
3  """
   Script pour ajouter des livres de test à la bibliothèque
   """
   -> Docstring du fichier expliquant son but.

6  from app import app, db
   -> Importe l'application Flask et l'objet `db` (SQLAlchemy) depuis `app.py`.
7  from models import Ouvrage, Exemplaire
   -> Importe les modèles `Ouvrage` et `Exemplaire` pour créer des enregistrements.
8  from datetime import datetime
   -> Importe `datetime` pour marquer la date d'acquisition des exemplaires.

10 def ajouter_livres_test():
   -> Définition d'une fonction qui ajoute un lot de livres de test.
11     """Ajoute des livres dans la base de données"""
   -> Docstring de la fonction.

13     with app.app_context():
   -> Ouvre le contexte d'application Flask (nécessaire pour accéder à la base depuis un script externe).

15-46  print(...) et livres_test = [ {...}, ... ]
   -> Affiche un en-tête et définit une liste de dictionnaires `livres_test` contenant les métadonnées de chaque livre.

48     compteur = 0
49     deja_existants = 0
   -> Variables pour compter les ajouts et les doublons.

51     for livre in livres_test:
   -> Boucle sur chaque dictionnaire représentant un livre.
53         existant = None
54         if livre['isbn']:
55             existant = Ouvrage.query.filter_by(isbn=livre['isbn']).first()
   -> Si l'ISBN est fourni, recherche un ouvrage existant par ISBN.
57         if not existant:
58             existant = Ouvrage.query.filter_by(titre=livre['titre'], auteur=livre['auteur']).first()
   -> Sinon (ou en complément) recherche par titre + auteur pour éviter doublons sans ISBN.

60         if not existant:
61             # Créer le nouvel ouvrage
62             ouvrage = Ouvrage(...)
   -> Crée une instance `Ouvrage` en utilisant les champs du dictionnaire.

74             db.session.add(ouvrage)
75             db.session.flush()  # Pour obtenir l'ID
   -> `flush()` synchronise la session avec la DB pour obtenir l'ID généré avant commit.

78             for i in range(livre['exemplaires']):
79                 numero = f"{livre['isbn']}-{i+1:03d}" if livre['isbn'] else f"{ouvrage.id}-{i+1:03d}"
   -> Génère un numéro d'exemplaire unique (soit basé sur l'ISBN, soit sur l'ID de l'ouvrage).

81                 exemplaire = Exemplaire(...)
82                 db.session.add(exemplaire)
   -> Crée et ajoute chaque `Exemplaire` lié à l'ouvrage.

85             compteur += 1
86             print(f"  ✅ [{compteur}] Ajouté : {livre['titre']} ({livre['exemplaires']} ex.)")
   -> Incrémente le compteur et affiche un message de succès.
88         else:
89             deja_existants += 1
90             print(f"  ⏭️  Déjà existant : {livre['titre']}")
   -> Si l'ouvrage existe déjà, compte et affiche un message.

93         db.session.commit()
   -> Sauvegarde toutes les modifications apportées dans la session.

95-103 Affichage du résumé (compteur, deja_existants, totaux via requêtes Ouvrage.query.count())
   -> Montre le résultat final.

105 if __name__ == '__main__':
106     ajouter_livres_test()
   -> Exécute `ajouter_livres_test()` si le script est lancé directement.

--- ajouter_usagers.py ---
Structure très similaire à `ajouter_livres.py`. Explications principales :
1-6 Shebang + encodage + docstring.
8  from app import app, db
9  from models import Usager
10 from datetime import datetime
   -> Importe l'application, la base et le modèle `Usager`.

12 def ajouter_usagers_test():
14     with app.app_context():
   -> Même logique : ouvrir le contexte d'app Flask.

18-46 usagers_test = [ {...}, ... ]
   -> Liste d'usagers de test (nom, prenom, email, telephone, adresse, statut).

48 compteur = 0
49 deja_existants = 0

51 for usager_data in usagers_test:
52     existant = Usager.query.filter_by(email=usager_data['email']).first()
   -> Vérification par email (champ unique) pour éviter doublons.

54 if not existant:
55     usager = Usager(..., date_inscription=datetime.now())
56     db.session.add(usager)
57     compteur += 1
   -> Création et ajout de l'usager avec date d'inscription.

61 db.session.commit()
   -> Commit final.

63-71 Affichage du résumé : totaux et comptages par statut.

73 if __name__ == '__main__':
74     ajouter_usagers_test()

--- app.py ---
En-tête (imports) :
1  from flask import Flask, render_template, request, redirect, url_for, flash, jsonify
   -> Import des outils Flask utilisés (rendu templates, gestion des requêtes, redirections, flash messages, JSON API).
2  from flask_login import LoginManager, login_user, logout_user, login_required, current_user
   -> Gestion de l'authentification des bibliothécaires.
3  from werkzeug.security import generate_password_hash
   -> Utilisé pour hasher les mots de passe (le check est dans `models`).
4  from datetime import datetime, timedelta
5  import json

7  app = Flask(__name__)
   -> Création de l'application Flask.

10 from database import db, init_app
11 init_app(app)
   -> Initialisation de la base de données (configuration SQLAlchemy + SECRET_KEY).

14 from models import *
   -> Importe tous les modèles (Usager, Ouvrage, Exemplaire, Emprunt, Reservation, Bibliothecaire).

17-22 Configuration Flask-Login :
17 login_manager = LoginManager()
18 login_manager.init_app(app)
19 login_manager.login_view = 'login'

21 @login_manager.user_loader
def load_user(user_id):
    return Bibliothecaire.query.get(int(user_id))
   -> Fonction de rappel pour charger l'utilisateur connecté par son id.

Routes publiques :
- `/` : `index()` rend `index.html`.
- `/catalogue` : `catalogue()` récupère le paramètre `search`. Si fourni, filtre par titre ou auteur en utilisant `contains()` (SQLAlchemy). Sinon récupère tous les ouvrages.

Authentification :
- `/login` : Gère GET (affiche form) et POST (récupère `login` et `password`, cherche `Bibliothecaire` par `login`, vérifie `check_password`, appelle `login_user()` et redirige vers `dashboard` si OK, sinon flash d'erreur).
- `/logout` : `logout_user()` puis redirection vers `index`.

Dashboard :
- `/dashboard` : affiche statistiques calculées via des requêtes `.count()` et passe `now=datetime.now()` au template.

Gestion des ouvrages (routes admin) :
- `/admin/ouvrages` : liste d'ouvrages (avec recherche possible par titre/auteur/isbn).
- `/admin/ouvrage/ajouter` : GET montre le formulaire ; POST crée `Ouvrage`, `Exemplaire`s, commit et message flash.
- `/admin/ouvrage/<int:id>` : montre détail d'un ouvrage et ses exemplaires.

Gestion des usagers :
- `/admin/usagers` : liste usagers (filtre search sur nom/prenom/email).
- `/admin/usager/ajouter` : POST crée `Usager` après vérification d'unicité email.
- `/admin/usager/<int:id>/modifier` : GET pour formulaire, POST pour appliquer les modifications.
- `/admin/usager/<int:id>/supprimer` : vérifie s'il y a des emprunts actifs (bloque la suppression si oui), sinon supprime.

Gestion des emprunts :
- `/admin/emprunts` : liste emprunts.
- `/admin/emprunt/nouveau` : POST vérifie l'usager (existence, statut actif, nombre d'emprunts < 5), vérifie disponibilité de l'ouvrage, trouve un exemplaire disponible, crée `Emprunt` et commit. Possibilité de fournir `date_retour` personnalisée au format `%Y-%m-%d`.
- `/admin/emprunt/retour/<int:id>` : marque `date_retour_reelle` et `statut='retourné'`.
- `/admin/emprunt/prolonger/<int:id>` : vérifie conditions (en_cours, prolongations < 2), ajoute 7 jours et incrémente `prolongations`.

Réservations :
- `/admin/reservations` : liste des réservations.

API :
- `/api/ouvrage/<int:id>/disponibilite` : retourne JSON avec disponibilité, exemplaires disponibles et total.

Initialisation :
- `create_default_admin()` : crée un administrateur par défaut `admin`/`admin123` si aucun bibliothécaire n'existe.

--- database.py ---
1  from flask_sqlalchemy import SQLAlchemy
2  import os
3  import secrets

5  db = SQLAlchemy()
   -> Objet SQLAlchemy partagé par les modules.

7  def init_app(app):
8      """Initialise l'application avec la base de données"""
9      app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///bibliotheque.db'
10     app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
11     app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY') or secrets.token_hex(32)

13     db.init_app(app)

15     with app.app_context():
16         db.create_all()
   -> Configure l'URI SQLite, désactive le suivi des modifications, génère une `SECRET_KEY` sécurisée si non fournie et crée les tables.

--- models.py ---
Fichier central des modèles SQLAlchemy. Chaque classe représente une table. Expliqué par blocs :

Usager:
- champs : `id`, `nom`, `prenom`, `email` (unique), `telephone`, `adresse`, `date_inscription`, `statut`.
- relations : `emprunts`, `reservations` (backrefs).
- méthodes : `peut_emprunter()` qui vérifie le statut et limite d'emprunts (5).

Ouvrage:
- champs : `id`, `titre`, `auteur`, `isbn` (unique), `annee_publication`, `editeur`, `categorie`, `description`, `nombre_exemplaires`, `date_ajout`.
- relations : `exemplaires`, `reservations`.
- méthodes : `exemplaires_disponibles()` calcule disponibles en soustrayant les exemplaires empruntés ; `est_disponible()` teste > 0.

Exemplaire:
- champs : `id`, `ouvrage_id` (FK), `numero`, `etat`, `date_acquisition`.
- relation : `emprunts`.
- méthode : `est_disponible()` qui vérifie s'il n'y a pas d'emprunts actifs sur cet exemplaire.

Emprunt:
- champs : `id`, `usager_id` (FK), `exemplaire_id` (FK), `date_emprunt`, `date_retour_prevue`, `date_retour_reelle`, `statut`, `prolongations`.
- __init__ : si `date_retour_prevue` non fourni, fixe par défaut à 21 jours.
- méthodes : `est_en_retard()`, `peut_prolonger()` (max 2 prolongations, pas si en retard), `prolonger()`.

Reservation:
- champs : `id`, `usager_id`, `ouvrage_id`, `date_reservation`, `date_expiration`, `statut`, `priorite`.
- __init__ : si pas de `date_expiration`, défini à 7 jours par défaut.

Bibliothecaire:
- champs : `id`, `nom`, `prenom`, `login` (unique), `password_hash`, `date_creation`.
- méthodes de hash/check du mot de passe (`set_password`, `check_password`).
- hérite de `UserMixin` pour Flask-Login.

--- controllers.py ---
Classe `GestionBibliotheque` qui encapsule la logique métier (service layer) :
- `ajouter_ouvrage(...)` : ajoute `Ouvrage` + crée exemplaires.
- `inscrire_usager(...)` : ajoute `Usager`.
- `emprunter_ouvrage(...)` : vérifie si usager peut emprunter (utilise `Usager.peut_emprunter()`), trouve exemplaire disponible, crée `Emprunt`.
- `retourner_emprunt(...)` : marque le retour, met à jour les réservations associées (honorer la première en attente).
- `reserver_ouvrage(...)` : crée `Reservation` en calculant la `priorite`.
- `get_statistiques()` : retourne un dict avec divers comptages.

Remarque : `controllers.py` sert à isoler la logique applicative pour tests ou réutilisation hors routes.

--- populate.py ---
Script qui réinitialise et peuple la base avec un jeu de données :
- Supprime (delete) les tables Exemplaire, Ouvrage, Usager (simple suppression via SQLAlchemy ORM).
- Ajoute une liste d'ouvrages test et crée leurs exemplaires.
- Ajoute plusieurs usagers de test.
- Commit et affiche résumé.

=== TEMPLATES HTML ===
Pour t'apprendre à lire et modifier les templates, j'explique les blocs et les parties importantes (les templates sont nombreux et répétitifs).

Règles générales des templates :
- Héritage : la plupart `extend "base.html"` — `base.html` contient l'entête HTML commun, la navbar, l'inclusion de `style.css` et `script.js`, et les blocs `title`, `content`, `scripts`.
- Utilisation de Jinja : `{{ ... }}` pour expressions, `{% ... %}` pour instructions Jinja (boucles, conditions, blocs).

Points clefs par template :

- `base.html` : définit la structure, inclut Bootstrap et icons, affiche `get_flashed_messages`, vérifie `current_user.is_authenticated` pour afficher les liens admin.
  -> Important : change `SECRET_KEY` si tu déploies (pour la sécurité des sessions).

- `index.html` : page d'accueil publique (formulaire minimal de recherche pointant vers `liste_ouvrages`).

- `catalogue.html` et `ouvrages.html` : affichent la liste des ouvrages. Utilisent `ouvrage.est_disponible()` et `ouvrage.exemplaires_disponibles()` pour badges visuels. `catalogue.html` affiche aussi le bouton "Détails" pour admins.

- `detail_ouvrage.html` : affiche les métadonnées d'un ouvrage, liste ses exemplaires et leur statut via `exemplaire.est_disponible()`.

- `ajouter_ouvrage.html` : formulaire d'ajout d'un ouvrage (titre, auteur, ISBN, nombre d'exemplaires, description). Le back-end `app.py` prend en POST les champs et crée `Ouvrage` + `Exemplaire`s.

- `ajouter_usager.html` / `modifier_usager.html` : formulaires pour ajouter/modifier un usager (vérifier que `email` est unique à la création). `modifier_usager.html` affiche des infos complémentaires (date_inscription, emprunts actifs).

- `login.html` : formulaire d'authentification admin ; les identifiants par défaut sont renseignés dans README mais changés en production.

- `nouvel_emprunt.html` : formulaire pour effectuer un emprunt (sélection usager actif + ouvrage). JS intégré montre la disponibilité de l'ouvrage et valide que les champs sont renseignés.

- `emprunts.html` : tableau d'emprunts avec actions (retour, prolongation). Les actions appellent les routes correspondantes définies dans `app.py`.

- `reservations.html` : affiche les réservations, leur statut, priorité, expiration ; contient actions simulées pour marquer comme honorée ou annuler.

- `usagers.html` : tableau d'usagers, actions pour modifier, suspendre/activer et supprimer. Note : certains formulaires POST utilisent `modifier_usager` pour changer le statut via champs cachés.

=== FICHIERS STATIQUES ===

- `static/css/style.css` : styles personnalisés (couleurs, ombres, animation `fadeIn`).
- `static/js/script.js` : scripts pour fermer automatiquement les alertes flash, validation simple de formulaires, fonctions globales utilitaires (`checkDisponibilite`, `checkUsagerEmprunt`).

=== FICHIERS DOCUMENTATION ===

- `README.md` : instructions d'installation, commandes utiles pour initialiser la DB (`populate.py`, `ajouter_livres.py`, `ajouter_usagers.py`), identifiants par défaut, liste des routes et fonctionnalités.
- `CORRECTIONS.md` : historique des corrections appliquées au projet (utile pour comprendre pourquoi certaines décisions ont été prises).
- `requirements.txt` : liste des dépendances (versions suggérées) pour installer via `pip install -r requirements.txt`.

=== CONSEILS POUR APPRENTISSAGE (comment utiliser ce fichier) ===
- Lis d'abord `models.py` pour comprendre les entités et leurs relations (c'est la base du reste).
- Ensuite `app.py` pour voir comment les routes utilisent ces modèles (flux: formulaire -> validation -> ORM -> commit -> template).
- Lis `controllers.py` si tu veux séparer logique métier hors routes et faciliter les tests.
- Pratique : modifie un petit champ (ex: ajouter un `print()` dans `ajouter_usagers.py`) et exécute `python ajouter_usagers.py` pour voir l'effet.

=== SUITES / ITÉRATIONS POSSIBLES ===
- Si tu veux, je peux :
  - Générer une explication ligne-par-ligne encore plus détaillée pour chaque template HTML (actuellement elles sont expliquées par section).
  - Séparer le fichier d'explications par fichier individuel (un fichier par source) pour faciliter l'étude.
  - Ajouter des exercices et mini-quizzes basés sur le code pour t'entraîner.

Fin du fichier d'explications initiales.
